<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/RevitAddin/WorksetSelectorWindow.xaml.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/RevitAddin/WorksetSelectorWindow.xaml.cs" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.Linq;&#10;using System.Windows;&#10;&#10;namespace KTool.Revit&#10;{&#10;    public partial class WorksetSelectorWindow : Window&#10;    {&#10;        public List&lt;string&gt; SelectedWorksets { get; private set; }&#10;&#10;        public WorksetSelectorWindow(IList&lt;string&gt; worksets)&#10;        {&#10;            InitializeComponent();&#10;            // ...existing code...&#10;            WorksetListBox.ItemsSource = worksets;&#10;        }&#10;&#10;        private void Ok_Click(object sender, RoutedEventArgs e)&#10;        {&#10;            SelectedWorksets = WorksetListBox.SelectedItems.Cast&lt;string&gt;().ToList();&#10;            DialogResult = true;&#10;            Close();&#10;        }&#10;&#10;        private void Cancel_Click(object sender, RoutedEventArgs e)&#10;        {&#10;            DialogResult = false;&#10;            Close();&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/fill_detail_view_param.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/fill_detail_view_param.py" />
              <option name="originalContent" value="&quot;&quot;&quot;&#10;Find detail components whose Name begins with &quot;DI_&quot; in the selected view(s) or the active view,&#10;and set their &quot;2D_Rebar_View&quot; parameter to the name of the view they are in.&#10;&quot;&quot;&quot;&#10;&#10;import clr&#10;&#10;# Revit / RevitServices references&#10;clr.AddReference('RevitServices')&#10;from RevitServices.Persistence import DocumentManager&#10;from RevitServices.Transactions import TransactionManager&#10;&#10;clr.AddReference('RevitAPI')&#10;from Autodesk.Revit.DB import (&#10;    FilteredElementCollector,&#10;    BuiltInCategory,&#10;    View,&#10;    Viewport,            # added to support views selected on sheets&#10;)&#10;&#10;# Access documents&#10;doc = DocumentManager.Instance.CurrentDBDocument&#10;uiapp = DocumentManager.Instance.CurrentUIApplication&#10;uidoc = uiapp.ActiveUIDocument&#10;&#10;def get_views_to_process():&#10;    # If one or more views are selected, use those; also handle viewports on sheets.&#10;    sel_ids = uidoc.Selection.GetElementIds()&#10;    views = []&#10;    if sel_ids:&#10;        for eid in sel_ids:&#10;            el = doc.GetElement(eid)&#10;            if isinstance(el, View):&#10;                if not el.IsTemplate:&#10;                    views.append(el)&#10;            elif isinstance(el, Viewport):&#10;                # get the view hosted by the viewport&#10;                v = doc.GetElement(el.ViewId)&#10;                if isinstance(v, View) and not v.IsTemplate:&#10;                    views.append(v)&#10;    # fallback to active view if none collected&#10;    if not views:&#10;        av = doc.ActiveView&#10;        if av and not av.IsTemplate:&#10;            views = [av]&#10;    return views&#10;&#10;def collect_detail_components_in_view(view):&#10;    # Accept a View or a Viewport (or an element id that resolves to one).&#10;    # Resolve to an actual View instance, then collect detail components in that view.&#10;    resolved_view = None&#10;    if isinstance(view, View):&#10;        resolved_view = view&#10;    elif isinstance(view, Viewport):&#10;        resolved_view = doc.GetElement(view.ViewId)&#10;    else:&#10;        # try resolving an ElementId or other reference to an element&#10;        try:&#10;            el = doc.GetElement(view)&#10;            if isinstance(el, View):&#10;                resolved_view = el&#10;            elif isinstance(el, Viewport):&#10;                resolved_view = doc.GetElement(el.ViewId)&#10;        except Exception:&#10;            resolved_view = None&#10;&#10;    if not resolved_view:&#10;        return []&#10;&#10;    col = FilteredElementCollector(doc, resolved_view.Id) \&#10;        .OfCategory(BuiltInCategory.OST_DetailComponents) \&#10;        .WhereElementIsNotElementType()&#10;    return list(col)&#10;&#10;def set_parameter_if_applicable(elem, param_name, value):&#10;    p = elem.LookupParameter(param_name)&#10;    if p and not p.IsReadOnly:&#10;        try:&#10;            p.Set(value)&#10;            return True&#10;        except Exception:&#10;            return False&#10;    return False&#10;&#10;def main():&#10;    views = get_views_to_process()&#10;    if not views:&#10;        print(&quot;No views to process.&quot;)&#10;        return&#10;&#10;    updated = 0&#10;    TransactionManager.Instance.EnsureInTransaction(doc)&#10;    try:&#10;        for v in views:&#10;            comps = collect_detail_components_in_view(v)&#10;            for c in comps:&#10;                name = c.Name or &quot;&quot;&#10;                if name.startswith(&quot;DI_&quot;):&#10;                    if set_parameter_if_applicable(c, &quot;2D_Rebar_View&quot;, v.Name):&#10;                        updated += 1&#10;        TransactionManager.Instance.TransactionTaskDone()&#10;    except Exception as ex:&#10;        # rollback if TransactionManager didn't already close&#10;        try:&#10;            TransactionManager.Instance.ForceCloseTransaction()&#10;        except Exception:&#10;            pass&#10;        raise&#10;&#10;    # report&#10;    print(&quot;Updated {} detail element(s)&quot;.format(updated))&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Find detail components whose Name begins with &quot;DI_&quot; in the selected view(s) or the active view,&#10;and set their &quot;2D_Rebar_View&quot; parameter to the name of the view they are in.&#10;&quot;&quot;&quot;&#10;&#10;import clr&#10;&#10;# Revit / RevitServices references&#10;clr.AddReference('RevitServices')&#10;from RevitServices.Persistence import DocumentManager&#10;from RevitServices.Transactions import TransactionManager&#10;&#10;clr.AddReference('RevitAPI')&#10;from Autodesk.Revit.DB import (&#10;    FilteredElementCollector,&#10;    BuiltInCategory,&#10;    View,&#10;    Viewport,            # added to support views selected on sheets&#10;)&#10;&#10;# Access documents&#10;doc = DocumentManager.Instance.CurrentDBDocument&#10;uiapp = DocumentManager.Instance.CurrentUIApplication&#10;uidoc = uiapp.ActiveUIDocument&#10;&#10;def get_views_to_process():&#10;    # If one or more views are selected, use those; also handle viewports on sheets.&#10;    sel_ids = uidoc.Selection.GetElementIds()&#10;    views = []&#10;    if sel_ids:&#10;        for eid in sel_ids:&#10;            el = doc.GetElement(eid)&#10;            if isinstance(el, View):&#10;                if not el.IsTemplate:&#10;                    views.append(el)&#10;            elif isinstance(el, Viewport):&#10;                # get the view hosted by the viewport&#10;                v = doc.GetElement(el.ViewId)&#10;                if isinstance(v, View) and not v.IsTemplate:&#10;                    views.append(v)&#10;    # fallback to active view if none collected&#10;    if not views:&#10;        av = doc.ActiveView&#10;        if av and not av.IsTemplate:&#10;            views = [av]&#10;    return views&#10;&#10;def collect_detail_components_in_view(view):&#10;    # Accept a View or a Viewport (or an element id that resolves to one).&#10;    # Resolve to an actual View instance, then collect detail components in that view.&#10;    resolved_view = None&#10;    if isinstance(view, View):&#10;        resolved_view = view&#10;    elif isinstance(view, Viewport):&#10;        resolved_view = doc.GetElement(view.ViewId)&#10;    else:&#10;        # try resolving an ElementId or other reference to an element&#10;        try:&#10;            el = doc.GetElement(view)&#10;            if isinstance(el, View):&#10;                resolved_view = el&#10;            elif isinstance(el, Viewport):&#10;                resolved_view = doc.GetElement(el.ViewId)&#10;        except Exception:&#10;            resolved_view = None&#10;&#10;    if not resolved_view:&#10;        return []&#10;&#10;    col = FilteredElementCollector(doc, resolved_view.Id) \&#10;        .OfCategory(BuiltInCategory.OST_DetailComponents) \&#10;        .WhereElementIsNotElementType()&#10;    return list(col)&#10;&#10;def set_parameter_if_applicable(elem, param_name, value):&#10;    p = elem.LookupParameter(param_name)&#10;    if p and not p.IsReadOnly:&#10;        try:&#10;            p.Set(value)&#10;            return True&#10;        except Exception:&#10;            return False&#10;    return False&#10;&#10;def main():&#10;    views = get_views_to_process()&#10;    if not views:&#10;        print(&quot;No views to process.&quot;)&#10;        return&#10;&#10;    updated = 0&#10;    TransactionManager.Instance.EnsureInTransaction(doc)&#10;    try:&#10;        for v in views:&#10;            comps = collect_detail_components_in_view(v)&#10;            for c in comps:&#10;                name = c.Name or &quot;&quot;&#10;                if name.startswith(&quot;DI_&quot;):&#10;                    if set_parameter_if_applicable(c, &quot;2D_Rebar_View&quot;, v.Name):&#10;                        updated += 1&#10;        TransactionManager.Instance.TransactionTaskDone()&#10;    except Exception as ex:&#10;        # rollback if TransactionManager didn't already close&#10;        try:&#10;            TransactionManager.Instance.ForceCloseTransaction()&#10;        except Exception:&#10;            pass&#10;        raise&#10;&#10;    # report&#10;    print(&quot;Updated {} detail element(s)&quot;.format(updated))&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>